# Predefined Workflows

## Overview

The Unified Agent System includes **advanced AI orchestration** with predefined workflows that intelligently coordinate multiple agents to accomplish complex, multi-step tasks. These workflows provide structured approaches with **intelligent agent selection**, **parallel execution optimization**, and **real-time collaboration coordination**.

## Advanced Orchestration Philosophy

The system follows an **intelligent conductor model** where advanced AI orchestrators coordinate specialized agents with sophisticated intelligence - analyzing complexity, optimizing collaboration, and adapting workflows based on real-time performance and success patterns.

### Advanced Orchestration Principles

1. **Intelligent Agent Selection**: AI-powered agent matching with compatibility analysis and performance optimization
2. **Multi-Dimensional Analysis**: Complex scoring across technical, domain, workflow, and risk dimensions
3. **Parallel Execution Optimization**: Dynamic workflow generation with dependency management and resource optimization
4. **Real-Time Collaboration**: Inter-agent communication protocols with context sharing and conflict resolution
5. **Adaptive Learning**: Continuous improvement based on success patterns and performance analytics
6. **Quality Coordination**: Strategic quality gates with automated validation and integration checkpoints

## Three-Phase Orchestration Model

### Phase 1: Research & Discovery üîç
**Objective**: Understand the problem space and gather necessary context

**Activities:**
- Project Analysis: Examine codebase structure, dependencies, and patterns
- Requirement Clarification: Understand user goals and constraints
- Technology Assessment: Identify relevant frameworks, tools, and patterns
- Risk Identification: Spot potential challenges and complexity factors

### Phase 2: Strategic Planning üìã
**Objective**: Design comprehensive implementation approach

**Activities:**
- Architecture Design: Plan system changes and component interactions
- Technology Selection: Choose appropriate libraries, patterns, and tools
- Implementation Sequencing: Define step-by-step execution plan
- Quality Assurance: Plan testing, security, and performance validation

### Phase 3: Coordinated Execution ‚ö°
**Objective**: Implement the solution with quality coordination

**Activities:**
- Parallel Implementation: Execute independent tasks simultaneously
- Sequential Dependencies: Handle tasks that depend on previous outputs
- Integration Coordination: Ensure components work together seamlessly
- Quality Validation: Test, review, and validate all implementations

## Advanced Orchestration Workflows

### Intelligent Multi-Agent Coordination
Leveraging the advanced orchestration system for optimal agent collaboration.

#### Complex System Development with Intelligence
**Orchestrator**: `@orchestrator` (Master AI coordination)
**Complexity Analysis**: Multi-dimensional scoring (technical, domain, workflow, risk)
**Agent Selection**: AI-powered compatibility analysis and optimal team assembly

```bash
# Example: Build scalable e-commerce platform
"Use @orchestrator to build a scalable e-commerce platform with microservices, payment processing, and mobile apps"

# Expected Orchestration:
# Phase 1: Discovery (Parallel) - @project-analyst + @business-analyst + @ux-designer
# Phase 2: Strategic Planning - @tech-lead-orchestrator coordinates architecture decisions
# Phase 3: Optimized Implementation - Multiple parallel streams with real-time coordination
```

**Advanced Features:**
- **Smart Team Assembly**: Auto-selects optimal agent combinations based on success patterns
- **Parallel Stream Optimization**: Identifies independent workstreams for parallel execution
- **Quality Gate Integration**: Strategic checkpoints with automated validation
- **Real-Time Adaptation**: Dynamic workflow adjustments based on intermediate results

#### Strategic Enterprise Architecture
**Orchestrator**: `@tech-lead-orchestrator` (Strategic technical leadership)
**Specialization**: Enterprise-scale decisions, multi-team coordination, technical risk management

```bash  
# Example: Design enterprise microservices architecture
"Use @tech-lead-orchestrator to design enterprise microservices architecture with security, compliance, and multi-team coordination"

# Expected Leadership:
# Strategic Foundation: Architecture council coordination with risk assessment
# Multi-Team Coordination: Cross-functional team leadership and resource optimization  
# Implementation Oversight: Senior-level quality governance and technical decisions
```

**Leadership Capabilities:**
- **Architecture Decision Records**: Documented technical decisions with rationale
- **Multi-Team Coordination**: Cross-functional team leadership and conflict resolution
- **Technical Risk Management**: Comprehensive risk assessment and mitigation strategies
- **Strategic Technology Planning**: Long-term technology roadmap and capability development

#### Intelligent Project Analysis & Planning
**Orchestrator**: `@project-analyst` (PRD intelligence and requirements processing)
**Specialization**: Requirements analysis, task generation, stakeholder management

```bash
# Example: Analyze PRD and generate comprehensive project plan
"Use @project-analyst to analyze the mobile banking PRD and generate comprehensive task breakdown with dependencies"

# Expected Analysis:
# PRD Processing: Intelligent parsing, requirement extraction, stakeholder mapping
# Task Generation: AI-powered task decomposition with dependency analysis
# Complexity Assessment: Multi-dimensional complexity scoring across all domains
# Project Planning: Timeline estimation, resource planning, risk assessment
```

**Intelligence Features:**
- **AI-Powered Task Decomposition**: Automatic task generation from requirements
- **Multi-Dimensional Complexity Analysis**: Technical, business, team, and timeline scoring
- **Smart Dependency Mapping**: Intelligent dependency analysis with critical path optimization
- **Stakeholder Communication Strategy**: Advanced stakeholder management and change coordination

#### Auto-Optimized Team Configuration
**Orchestrator**: `@team-configurator` (Technology detection and team optimization)
**Specialization**: Stack detection, agent team assembly, performance optimization

```bash
# Example: Auto-configure optimal team for detected technology stack
"Use @team-configurator to analyze my Next.js + Supabase + TypeScript project and configure optimal agent team"

# Expected Configuration:
# Technology Detection: Automatic stack analysis and architecture pattern recognition
# Team Assembly: AI-powered agent selection with collaboration compatibility
# Performance Optimization: Dynamic team composition based on success metrics
# Custom Configuration: Project-specific agent customization and specialization
```

**Auto-Configuration Intelligence:**
- **Technology Stack Detection**: Automatic analysis of project files and frameworks
- **Optimal Team Composition**: Performance-based agent selection with success tracking
- **Dynamic Optimization**: Continuous team adjustment based on collaboration effectiveness
- **Custom Agent Specialization**: Project-specific agent configuration and enhancement

## Core Workflows

### Backend Resilience Implementation
Comprehensive backend resilience implementation across frameworks.

#### Phases
1. **Analysis** ‚Üí `@resilience-engineer` analyzes architecture gaps
2. **Logging Setup** ‚Üí `@logging-concepts-engineer` designs observability  
3. **Implementation** ‚Üí Framework specialists implement patterns
4. **Integration** ‚Üí Specialized logging agents integrate tools

#### Usage Example
```bash
claude "Implement resilience patterns across our Rails backend services"
```

#### Expected Agents
- `@resilience-engineer` (universal patterns)
- `@logging-concepts-engineer` (observability design)
- `@rails-backend-expert` (Rails-specific implementation)
- Framework-specific logging agents

### New Backend Service Development
Build a new backend service with resilience and logging from the start.

#### Phases
1. **Architecture** ‚Üí Universal agents design resilient foundation
2. **Implementation** ‚Üí Framework specialists build core functionality
3. **Specialization** ‚Üí Language-specific agents optimize patterns

#### Usage Example
```bash
claude "Build a new Django API service with circuit breakers and structured logging"
```

#### Expected Agents
- `@resilience-engineer` + `@logging-concepts-engineer` (foundation)
- `@django-backend-expert` (core implementation)
- `@python-hyx-resilience` (Python-specific patterns)

### Frontend Development Workflow
Modern frontend application development with error boundaries.

#### Phases
1. **Planning** ‚Üí `@project-analyst` + `@frontend-developer` plan architecture
2. **Component Design** ‚Üí Framework specialists design component architecture
3. **State Management** ‚Üí State specialists implement data flow
4. **Framework Integration** ‚Üí Meta-framework experts add optimizations

#### Usage Example
```bash
claude "Build a React dashboard with error boundaries and state management"
```

#### Expected Agents
- `@project-analyst` (requirements planning)
- `@react-component-architect` (component design)
- `@react-state-manager` (state implementation)
- `@react-nextjs-expert` (if Next.js integration needed)

### Product-Led Development
Complete product development workflow from requirements to launch.

#### Phases
1. **Requirements** ‚Üí `@product-manager` defines features and priorities
2. **Analysis** ‚Üí `@business-analyst` gathers stakeholder requirements
3. **Design** ‚Üí `@ux-designer` creates user flows and wireframes
4. **Architecture** ‚Üí Technical agents implement based on business needs

#### Usage Example
```bash
claude "Develop new payment feature from requirements to implementation"
```

#### Expected Agents
- `@product-manager` (feature definition)
- `@business-analyst` (requirements gathering)
- `@ux-designer` (user experience design)
- Technical implementation agents based on stack

### Infrastructure Deployment
End-to-end infrastructure deployment and operations workflow.

#### Phases
1. **Architecture** ‚Üí `@cloud-architect` designs scalable infrastructure
2. **Implementation** ‚Üí `@devops-troubleshooter` configures deployment pipelines
3. **Monitoring** ‚Üí `@database-admin` + monitoring specialists set up observability
4. **Response** ‚Üí `@incident-responder` handles production issues

#### Usage Example
```bash
claude "Deploy microservices to AWS with monitoring and incident response"
```

#### Expected Agents
- `@cloud-architect` (infrastructure design)
- `@devops-troubleshooter` (deployment configuration)
- `@database-admin` (data layer setup)
- `@incident-responder` (operational readiness)

## MCP-Enhanced Workflows

### Documentation-Driven Development
Development workflow enhanced with live documentation access.

#### Phases
1. `@documentation-specialist` + Context7 MCP ‚Üí Retrieve up-to-date library documentation
2. Framework specialists + Context7 MCP ‚Üí Access current patterns and best practices
3. `@software-engineering-expert` + Context7 MCP ‚Üí Validate implementation approaches

#### Usage Example
```bash
claude "Implement authentication using current Rails best practices with live documentation"
```

### Repository Operations Workflow
Git workflow management with live GitHub integration.

#### Phases
1. `@git-expert` + GitHub MCP ‚Üí Live repository analysis and operations
2. `@code-reviewer` + GitHub MCP ‚Üí Automated PR reviews with real-time feedback
3. `@cicd-pipeline-engineer` + GitHub MCP ‚Üí Workflow management and troubleshooting

#### Usage Example
```bash
claude "Create feature branch, implement changes, and submit PR with automated review"
```

### Project Management Workflow
Structured project management with task tracking.

#### Phases
1. `@project-analyst` + Task Master MCP ‚Üí PRD analysis and initial task generation
2. `@tech-lead-orchestrator` + Task Master MCP ‚Üí Project complexity assessment and expansion
3. Task Master MCP ‚Üí Continuous task tracking and dependency management across all agents

#### Usage Example
```bash
claude "Initialize project from PRD and set up task tracking with complexity analysis"
```

### Integrated Development Workflow
Complete development workflow with all MCP integrations.

#### Phases
1. **Planning** ‚Üí Task Master MCP generates structured tasks from requirements
2. **Research** ‚Üí Context7 MCP provides current documentation and examples
3. **Development** ‚Üí Framework specialists implement with GitHub MCP for live repo operations
4. **Review** ‚Üí `@code-reviewer` + GitHub MCP for automated quality assurance
5. **Deployment** ‚Üí `@release-manager` + GitHub MCP for orchestrated releases
6. **Tracking** ‚Üí Task Master MCP maintains project progress visibility

#### Usage Example
```bash
claude "Full feature development from requirements to deployment with task tracking"
```

## Specialized Workflows

### Security-First Development
Development workflow with integrated security practices.

#### Phases
1. **Security Assessment** ‚Üí `@security-auditor` conducts vulnerability analysis
2. **Secure Architecture** ‚Üí `@software-engineering-expert` + `@security-auditor` design secure systems
3. **Implementation** ‚Üí Framework specialists implement with security best practices
4. **Compliance Validation** ‚Üí Domain compliance agents validate regulatory requirements

#### Usage Example
```bash
claude "Build payment processing system with PCI compliance and security audit"
```

#### Expected Agents
- `@security-auditor` (security assessment)
- `@payment-integration-agent` (PCI compliance)
- `@software-engineering-expert` (secure architecture)
- Backend specialists with security focus

### Mobile Application Development
Cross-platform mobile development workflow.

#### Phases
1. **Product Planning** ‚Üí `@product-manager` defines mobile app requirements
2. **UX Design** ‚Üí `@ux-designer` creates mobile-optimized user experience
3. **Development** ‚Üí `@mobile-developer` builds cross-platform or native applications
4. **Integration** ‚Üí Backend specialists provide API support and data synchronization

#### Usage Example
```bash
claude "Build React Native app with offline capabilities and backend integration"
```

### Legacy System Modernization
Systematic approach to modernizing legacy systems.

#### Phases
1. **Assessment** ‚Üí `@code-archaeologist` + `@code-refactoring-specialist` analyze legacy systems
2. **Planning** ‚Üí `@code-refactoring-specialist` creates modernization roadmap
3. **Implementation** ‚Üí `@software-engineering-expert` + framework specialists execute refactoring
4. **Migration** ‚Üí `@terraform-specialist` + `@cloud-architect` handle infrastructure modernization

#### Usage Example
```bash
claude "Modernize legacy Rails monolith into microservices architecture"
```

## Collaboration Patterns

### Hierarchical Collaboration
Technical leadership coordination with clear chain of command.

```bash
# Technical leadership coordination
claude "Use @tech-lead-orchestrator to coordinate @rails-backend-expert, @react-component-architect, and @database-admin for our e-commerce platform"
```

**Pattern:**
- Lead agent coordinates multiple specialists
- Clear delegation of responsibilities
- Unified architecture vision
- Comprehensive integration planning

### Cross-Domain Expertise
Multiple agents from different domains collaborate on interdisciplinary problems.

```bash
# Security-focused development
claude "Use @security-auditor with @rails-backend-expert to build secure authentication, @database-admin for secure data handling, and @cloud-architect for infrastructure security"
```

**Pattern:**
- Domain experts contribute specialized knowledge
- Cross-functional collaboration
- Comprehensive problem-solving approach
- Knowledge sharing between domains

### Problem-Solving Chains
Sequential agent activation for complex workflows with dependencies.

```bash
# Incident response workflow
claude "Use @incident-responder to coordinate, @devops-troubleshooter to diagnose, @database-admin to check data integrity, and @error-detective to analyze logs"
```

**Pattern:**
- Sequential problem resolution steps
- Clear hand-offs between agents
- Cumulative knowledge building
- Systematic approach to complex issues

### Knowledge Transfer
Agents share expertise and context to accelerate learning.

```bash
# Learning from experts
claude "Use @code-archaeologist to understand legacy code, then @software-engineering-expert to refactor with @rails-backend-expert for Rails-specific patterns"
```

**Pattern:**
- Knowledge extraction from existing systems
- Best practice application
- Framework-specific optimization
- Continuous learning and improvement

## Workflow Customization

### Workflow Configuration
Workflows can be customized in `agents.json`:

```json
{
  "workflows": {
    "custom-workflow": {
      "description": "Custom workflow description",
      "phases": [
        {
          "name": "phase1",
          "agents": ["agent1", "agent2"],
          "description": "Phase 1 description"
        },
        {
          "name": "phase2",
          "agents": ["agent3", "agent4"],
          "description": "Phase 2 description"
        }
      ]
    }
  }
}
```

### Phase Dependencies
Define dependencies between workflow phases:

```json
{
  "phases": [
    {
      "name": "planning",
      "agents": ["product-manager", "business-analyst"],
      "dependencies": []
    },
    {
      "name": "implementation",
      "agents": ["rails-backend-expert", "react-component-architect"],
      "dependencies": ["planning"]
    }
  ]
}
```

### Parallel Execution
Some workflow phases can execute in parallel:

```json
{
  "phases": [
    {
      "name": "backend-development",
      "agents": ["rails-backend-expert"],
      "parallel": true
    },
    {
      "name": "frontend-development", 
      "agents": ["react-component-architect"],
      "parallel": true
    }
  ]
}
```

## Workflow Execution

### Manual Workflow Execution
Execute workflows step-by-step with explicit control:

```bash
# Phase 1: Planning
claude "Use @product-manager to define feature requirements"

# Phase 2: Analysis  
claude "Use @business-analyst to detail stakeholder requirements"

# Phase 3: Implementation
claude "Use @rails-backend-expert to implement backend with @react-component-architect for frontend"
```

### Automated Workflow Execution
Let agents coordinate workflow execution automatically:

```bash
# Orchestrated workflow
claude "Use @tech-lead-orchestrator to execute complete feature development workflow from requirements to deployment"
```

### Conditional Workflow Execution
Workflows that adapt based on conditions:

```bash
# Conditional branching
claude "Use @project-analyst to analyze requirements, then route to appropriate framework specialists based on detected stack"
```

## Best Practices

### Workflow Design
1. **Clear Phases**: Define distinct workflow phases with specific outcomes
2. **Agent Matching**: Match agents to phases based on expertise and capabilities
3. **Dependencies**: Clearly define phase dependencies and prerequisites
4. **Flexibility**: Allow for workflow adaptation based on project needs

### Execution Strategies
1. **Progressive Enhancement**: Start with basic workflow, enhance with specialized agents
2. **Parallel Processing**: Execute independent phases in parallel when possible
3. **Error Handling**: Include error handling and recovery strategies
4. **Progress Tracking**: Provide clear progress updates throughout workflow execution

### Collaboration Optimization
1. **Context Sharing**: Ensure agents can share relevant context and decisions
2. **Handoff Protocols**: Define clear handoff procedures between workflow phases
3. **Quality Gates**: Include quality checkpoints throughout workflows
4. **Feedback Loops**: Allow for iterative improvement based on workflow outcomes

### Performance Considerations
1. **Resource Management**: Balance agent load and resource utilization
2. **Caching**: Cache workflow results and intermediate outputs when appropriate
3. **Optimization**: Continuously optimize workflow efficiency based on usage patterns
4. **Monitoring**: Monitor workflow performance and success rates

## Enterprise Integration Patterns

### CI/CD Pipeline Integration

#### GitHub Actions
```yaml
# .github/workflows/agent-quality-gates.yml
name: Agent Quality Gates

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  agent-review:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Security Review
        run: |
          claude "Use @security-auditor to audit this PR for vulnerabilities" \
            --format json > security-review.json
            
      - name: Performance Review
        run: |
          claude "Use @performance-optimizer to analyze performance impact" \
            --format json > performance-review.json
            
      - name: Comment PR
        uses: actions/github-script@v6
        with:
          script: |
            const securityReview = require('./security-review.json');
            const performanceReview = require('./performance-review.json');
            
            const comment = `
            ## Agent Review Results
            
            ### Security Analysis
            ${securityReview.summary}
            
            ### Performance Analysis  
            ${performanceReview.summary}
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
```

#### Jenkins Pipeline Integration
```groovy
pipeline {
    agent any
    
    stages {
        stage('Agent Review') {
            parallel {
                stage('Security Review') {
                    steps {
                        script {
                            sh '''
                                claude "Use @security-specialist for enterprise security audit" \
                                  --output security-report.md
                            '''
                        }
                    }
                }
                
                stage('Code Quality') {
                    steps {
                        script {
                            sh '''
                                claude "Use @code-reviewer for maintainability review" \
                                  --output quality-report.md
                            '''
                        }
                    }
                }
            }
        }
        
        stage('Quality Gate') {
            steps {
                script {
                    def securityIssues = readFile('security-report.md').contains('CRITICAL')
                    if (securityIssues) {
                        error 'Critical security issues found by agent review'
                    }
                }
            }
        }
    }
}
```

### Git Integration Patterns

#### Pre-commit Hooks
```bash
#!/bin/sh
# .git/hooks/pre-commit

# Run agent-assisted code review before commit
claude "Use @code-reviewer to quick-check staged changes for quality and security" \
  --files $(git diff --cached --name-only)

if [ $? -ne 0 ]; then
    echo "Agent review found issues. Please address them before committing."
    exit 1
fi
```

#### Pull Request Templates
```markdown
<!-- .github/pull_request_template.md -->
## Agent-Assisted Review Checklist

- [ ] Code quality review completed with `@code-reviewer`
- [ ] Security scan completed with `@security-auditor`  
- [ ] Performance impact assessed with `@performance-optimizer`
- [ ] Documentation updated if needed

### Agent Recommendations
<!-- Paste agent feedback here -->

### Manual Review Notes
<!-- Additional human review comments -->
```

## Team Configuration Patterns

### Large Team Coordination
```json
// .claude/team-assignments.json
{
  "teams": {
    "frontend": {
      "primary_agents": ["react-expert", "ux-designer"],
      "secondary_agents": ["performance-optimizer", "accessibility-specialist"]
    },
    "backend": {
      "primary_agents": ["rails-expert", "api-architect"],
      "secondary_agents": ["database-admin", "security-auditor"]
    },
    "devops": {
      "primary_agents": ["devops-troubleshooter", "cloud-architect"],
      "secondary_agents": ["security-auditor", "observability-engineer"]
    }
  }
}
```

### Project-Specific Customization
```json
// .claude/team-config.json
{
  "conventions": {
    "code_style": "prettier + eslint-config-airbnb", 
    "testing": "jest + react-testing-library",
    "deployment": "vercel",
    "database": "postgresql"
  },
  "preferences": {
    "state_management": "zustand",
    "styling": "tailwind + shadcn/ui",
    "api_client": "tanstack-query"  
  }
}
```

## Troubleshooting Workflows

### Common Issues
1. **Agent Conflicts**: Multiple agents providing conflicting recommendations
2. **Dependency Failures**: Workflow phases failing due to unmet dependencies
3. **Resource Constraints**: Insufficient resources for parallel workflow execution
4. **Context Loss**: Important context lost between workflow phases

### Debugging Strategies
1. **Phase Isolation**: Test individual workflow phases independently
2. **Agent Testing**: Verify individual agent functionality before workflow execution
3. **Dependency Validation**: Ensure all workflow dependencies are satisfied
4. **Progress Monitoring**: Monitor workflow progress and identify bottlenecks

### Configuration Validation
```bash
#!/bin/bash
# scripts/validate-integration.sh

echo "Validating Unified Agent System Integration..."

# Check required directories
for dir in ".claude/agents" ".claude/agents/templates"; do
    if [ ! -d "$dir" ]; then
        echo "‚ùå Missing directory: $dir"
        exit 1
    else
        echo "‚úÖ Found: $dir"
    fi
done

# Check configuration files
if [ ! -f ".claude/agents.json" ]; then
    echo "‚ùå Missing configuration: .claude/agents.json"
    exit 1
else
    echo "‚úÖ Found: .claude/agents.json"
fi

# Validate JSON syntax
if ! python -m json.tool .claude/agents.json > /dev/null 2>&1; then
    echo "‚ùå Invalid JSON in .claude/agents.json"
    exit 1
else
    echo "‚úÖ Valid JSON configuration"
fi

echo "Integration validation complete!"
```

### Optimization Techniques
1. **Workflow Profiling**: Profile workflow execution to identify optimization opportunities
2. **Agent Tuning**: Optimize individual agent performance within workflows
3. **Parallel Optimization**: Optimize parallel workflow execution for better resource utilization
4. **Caching Strategy**: Implement intelligent caching for frequently used workflow components